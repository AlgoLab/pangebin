"""PangeBin-flow MILP variables library.

Here is base bricks to describe composition of variables.
"""

from __future__ import annotations

from itertools import chain, product
from typing import TYPE_CHECKING

import gurobipy as gp

import pangebin.gc_content.items as gc_items
import pangebin.gfa.link as gfa_link
import pangebin.gfa.segment as gfa_segment
import pangebin.plasbin.network as net

if TYPE_CHECKING:
    from collections.abc import Iterator


class Domain:
    """Variable domains.

    It follows the default logic of Gurobi.
    """

    @classmethod
    def binary(cls) -> Domain:
        """Binary domain."""
        return cls(gp.GRB.BINARY, 0, gp.GRB.INFINITY)

    @classmethod
    def continuous(cls, lb: float, ub: float) -> Domain:
        """Continuous domain."""
        return cls(gp.GRB.CONTINUOUS, lb, ub)

    def __init__(self, vtype: str, lb: float, ub: float) -> None:
        """Initialize domain."""
        self.vtype = vtype
        self.lb = lb
        self.ub = ub


def gen_var(
    model: gp.Model,
    domain: Domain,
    name: str,
) -> gp.Var:
    """Generate variable with the given name and domain."""
    return model.addVar(
        name=name,
        vtype=domain.vtype,
        lb=domain.lb,
        ub=domain.ub,
    )


def gen_vars(
    model: gp.Model,
    domain: Domain,
    name_prefix: str,
    object_id_generator: Iterator[str],
) -> Iterator[tuple[str, gp.Var]]:
    """Generate variables with names generated by the object id generator."""
    return (
        (
            object_id,
            gen_var(model, domain, f"{name_prefix}_{object_id}"),
        )
        for object_id in object_id_generator
    )


class SubVertices:
    """Subgraph defined by vertices.

    Defines:

    * x_i for all oriented fragment i
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        x_domain: Domain,
    ) -> None:
        self.__x: dict[str, gp.Var] = dict(
            gen_vars(model, x_domain, "x", map(str, network.oriented_fragments())),
        )

    def x(self, fragment: gfa_segment.OrientedFragment) -> gp.Var:
        """Get x_i variable, i in Fragments."""
        return self.__x[str(fragment)]


class SubArcs:
    """Subgraph defined by arcs.

    Defines:

    * y_a for all link-arcs, source-arcs and sink-arcs a
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        y_domain: Domain,
    ) -> None:
        self.__y: dict[str, gp.Var] = dict(
            gen_vars(model, y_domain, "y", net.StrFormatter.arc_ids(network)),
        )

    def s(self, source_arc: tuple[str, gfa_segment.OrientedFragment]) -> gp.Var:
        """Get y_a variable, a in source-arcs."""
        return self.__y[net.StrFormatter.s_arc(source_arc)]

    def l(self, arc: gfa_link.Link) -> gp.Var:  # noqa: E743
        """Get y_a variable, a in link-arcs."""
        return self.__y[net.StrFormatter.arc(arc)]

    def t(self, sink_arc: tuple[gfa_segment.OrientedFragment, str]) -> gp.Var:
        """Get y_a variable, a in sink-arcs."""
        return self.__y[net.StrFormatter.t_arc(sink_arc)]

    def incoming(
        self,
        network: net.Network,
        fragment: gfa_segment.OrientedFragment,
    ) -> gp.LinExpr:
        """Get linear expression for incoming flow."""
        in_y_arcs = chain(
            (
                self.l(link)
                for link in gfa_link.incoming_links(network.gfa_graph(), fragment)
            ),
        )
        if network.is_source_connected(fragment.identifier()):
            in_y_arcs = chain(
                in_y_arcs,
                iter((self.s((network.SOURCE_VERTEX, fragment)),)),
            )
        return gp.quicksum(in_y_arcs)


class Flow:
    """Flow variables.

    Defines:

    * f_a for all link-arcs, source-arcs and sink-arcs a
    * F the total flow
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        f_domain: Domain,
        total_flow_domain: Domain,
    ) -> None:
        self.__f: dict[str, gp.Var] = dict(
            gen_vars(model, f_domain, "f", net.StrFormatter.arc_ids(network)),
        )
        self.__total_flow = gen_var(model, total_flow_domain, "F")

    def s(self, source_arc: tuple[str, gfa_segment.OrientedFragment]) -> gp.Var:
        """Get f_a variable, a in source-arcs."""
        return self.__f[net.StrFormatter.s_arc(source_arc)]

    def l(self, arc: gfa_link.Link) -> gp.Var:  # noqa: E743
        """Get f_a variable, a in link-arcs."""
        return self.__f[net.StrFormatter.arc(arc)]

    def t(self, sink_arc: tuple[gfa_segment.OrientedFragment, str]) -> gp.Var:
        """Get f_a variable, a in sink-arcs."""
        return self.__f[net.StrFormatter.t_arc(sink_arc)]

    def total(self) -> gp.Var:
        """Get F variable."""
        return self.__total_flow

    def incoming(
        self,
        network: net.Network,
        fragment: gfa_segment.OrientedFragment,
    ) -> gp.LinExpr:
        """Get linear expression for incoming flow."""
        in_flow_arcs = chain(
            (
                self.l(link)
                for link in gfa_link.incoming_links(network.gfa_graph(), fragment)
            ),
        )
        if network.is_source_connected(fragment.identifier()):
            in_flow_arcs = chain(
                in_flow_arcs,
                iter((self.s((network.SOURCE_VERTEX, fragment)),)),
            )
        return gp.quicksum(in_flow_arcs)

    def outgoing(
        self,
        network: net.Network,
        fragment: gfa_segment.OrientedFragment,
    ) -> gp.LinExpr:
        """Get linear expression for outgoing flow."""
        out_flow_arcs = chain(
            (
                self.l(link)
                for link in gfa_link.outgoing_links(network.gfa_graph(), fragment)
            ),
        )
        if network.is_sink_connected(fragment.identifier()):
            out_flow_arcs = chain(
                out_flow_arcs,
                iter((self.t((fragment, network.SINK_VERTEX)),)),
            )
        return gp.quicksum(out_flow_arcs)

    def incoming_forward_reverse(
        self,
        network: net.Network,
        frag_id: str,
    ) -> gp.LinExpr:
        """Get linear expression for foward plus reverse incoming flows."""
        return gp.quicksum(
            self.incoming(network, frag) for frag in network.to_oriented(frag_id)
        )


class PositiveFlow:
    """Positive flow variables.

    Defines:

    * F_a for all link-arcs, source-arcs and sink-arcs a
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        pos_f_domain: Domain,
    ) -> None:
        # F_a for all arcs a
        self.__pos_f: dict[str, gp.Var] = dict(
            gen_vars(
                model,
                pos_f_domain,
                "pos_f",
                net.StrFormatter.arc_ids(network),
            ),
        )

    def s(
        self,
        source_arc: tuple[str, gfa_segment.OrientedFragment],
    ) -> gp.Var:
        """Get F_a variable, a in source-arcs."""
        return self.__pos_f[net.StrFormatter.s_arc(source_arc)]

    def l(self, arc: gfa_link.Link) -> gp.Var:  # noqa: E743
        """Get F_a variable, a in link-arcs."""
        return self.__pos_f[net.StrFormatter.arc(arc)]

    def t(
        self,
        sink_arc: tuple[gfa_segment.OrientedFragment, str],
    ) -> gp.Var:
        """Get F_a variable, a in sink-arcs."""
        return self.__pos_f[net.StrFormatter.t_arc(sink_arc)]


class ConnectedComponent:
    """Connected component variables.

    Defines:

    * alpha the number of vertices in the connected component
    * beta_uv is the depth of the subtree defined by root v
      for all (u, v) in link, source and sink-arcs
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        alpha_domain: Domain,
        beta_domain: Domain,
    ) -> None:
        # alpha, be the number of vertices in the connected component
        self.__alpha: gp.Var = gen_var(model, alpha_domain, "alpha")
        # Beta_uv is the depth of the subtree defined by root v
        self.__beta: dict[str, gp.Var] = dict(
            gen_vars(
                model,
                beta_domain,
                "beta",
                net.StrFormatter.arc_ids(network),
            ),
        )

    def alpha(self) -> gp.Var:
        """Get alpha variable."""
        return self.__alpha

    def beta_s(
        self,
        source_arc: tuple[str, gfa_segment.OrientedFragment],
    ) -> gp.Var:
        """Get beta_a variable, a in source-arcs."""
        return self.__beta[net.StrFormatter.s_arc(source_arc)]

    def beta(self, arc: gfa_link.Link) -> gp.Var:
        """Get beta_a variable, a in link-arcs."""
        return self.__beta[net.StrFormatter.arc(arc)]

    def beta_t(
        self,
        sink_arc: tuple[gfa_segment.OrientedFragment, str],
    ) -> gp.Var:
        """Get beta_a variable, a in sink-arcs."""
        return self.__beta[net.StrFormatter.t_arc(sink_arc)]

    def incoming_beta(
        self,
        network: net.Network,
        fragment: gfa_segment.OrientedFragment,
    ) -> gp.LinExpr:
        """Get linear expression for incoming beta."""
        in_beta_arcs = chain(
            (
                self.beta(link)
                for link in gfa_link.incoming_links(network.gfa_graph(), fragment)
            ),
        )
        if network.is_source_connected(fragment.identifier()):
            in_beta_arcs = chain(
                in_beta_arcs,
                iter((self.beta_s((network.SOURCE_VERTEX, fragment)),)),
            )
        return gp.quicksum(in_beta_arcs)

    def outgoing_beta(
        self,
        network: net.Network,
        fragment: gfa_segment.OrientedFragment,
    ) -> gp.LinExpr:
        """Get linear expression for outgoing beta."""
        out_beta_arcs = chain(
            (
                self.beta(link)
                for link in gfa_link.outgoing_links(network.gfa_graph(), fragment)
            ),
        )
        if network.is_sink_connected(fragment.identifier()):
            out_beta_arcs = chain(
                out_beta_arcs,
                iter((self.beta_t((fragment, network.SINK_VERTEX)),)),
            )
        return gp.quicksum(out_beta_arcs)


class SubFragments:
    """Sub fragment set variables.

    Defines:

    * frag_a for all fragments a
    """

    def __init__(
        self,
        network: net.Network,
        model: gp.Model,
        frag_domain: Domain,
    ) -> None:
        self.__frag: dict[str, gp.Var] = dict(
            gen_vars(model, frag_domain, "frag", network.fragment_ids()),
        )

    def x(self, frag_id: str) -> gp.Var:
        """Get frag variable."""
        return self.__frag[frag_id]


class GCIntervals:
    """Interval variables.

    Defines:

    * gc_a for all intervals a
    """

    def __init__(
        self,
        intervals: gc_items.Intervals,
        model: gp.Model,
        gc_domain: Domain,
    ) -> None:
        self.__gc: dict[str, gp.Var] = dict(
            gen_vars(
                model,
                gc_domain,
                "gc",
                map(gc_items.IntervalFormatter.to_str, intervals),
            ),
        )

    def x(self, interval: tuple[float, float]) -> gp.Var:
        """Get GC variable."""
        return self.__gc[gc_items.IntervalFormatter.to_str(interval)]


class FragmentGC:
    """Fragment interval variables.

    Defines:

    * frag_gc_ib for all fragments i and intervals b
    """

    def __init__(
        self,
        network: net.Network,
        intervals: gc_items.Intervals,
        model: gp.Model,
        frag_gc_domain: Domain,
    ) -> None:
        self.__frag_gc: dict[str, gp.Var] = dict(
            gen_vars(
                model,
                frag_gc_domain,
                "frag_gc",
                (
                    self.__fmt_frag_gc(*tup)
                    for tup in product(network.fragment_ids(), intervals)
                ),
            ),
        )

    def x(self, frag_id: str, interval: tuple[float, float]) -> gp.Var:
        """Get fragment GC variable."""
        return self.__frag_gc[self.__fmt_frag_gc(frag_id, interval)]

    def __fmt_frag_gc(self, frag_id: str, interval: tuple[float, float]) -> str:
        return f"{frag_id}_{gc_items.IntervalFormatter.to_str(interval)}"


class InflowGC:
    """Inflow interval variables.

    Defines:

    * inflow_gc_ib for all fragments i and intervals b
    """

    def __init__(
        self,
        network: net.Network,
        intervals: gc_items.Intervals,
        model: gp.Model,
        inflow_gc_domain: Domain,
    ) -> None:
        self.__inflow_gc: dict[str, gp.Var] = dict(
            gen_vars(
                model,
                inflow_gc_domain,
                "inflow_gc",
                (
                    self.__fmt_inflow_gc(*tup)
                    for tup in product(network.fragment_ids(), intervals)
                ),
            ),
        )

    def x(self, frag_id: str, interval: tuple[float, float]) -> gp.Var:
        """Get inflow GC variable."""
        return self.__inflow_gc[self.__fmt_inflow_gc(frag_id, interval)]

    def __fmt_inflow_gc(self, frag_id: str, interval: tuple[float, float]) -> str:
        return f"{frag_id}_{gc_items.IntervalFormatter.to_str(interval)}"
